# Scripting with Bash
## The 'Shebang' Line

```#!/bin/bash``` tells computer to use bash script even if you are using zsh
-

## Variables
- Allows you to store and manipulate data 
- e.g. variable=name
-  To access variable: ```$variable``` 
- Can use variables within strings

## Comments
- Add explanation using #

## Parameters
Inside .sh file:
- ```echo "Parameter 1: $1"`` # $1 is a variable that grabs the value while the value is passed into command line
- e.g. user runs file with the argument ```apple```
- It will say Parameter 1 is apple

## Arithemtic expansion
```$(( expression ))```
for e.g. you want to add the numbers, and you have num1&num2 and they were both assigned values, inside the brackets where it says expression, you would write ```num1+num2```

## e.g.

- ```num1=2```
- ```num2=4```
- ```result=$((num1+num2))```

```echo "$num1 + $num2 is equal to $result"```

## Arithemtic expansion with **Parameters**

## e.g.
- ```num1=$1```
- ```num2=$2```
- ```result=$((num$1+num$2))```

```echo "$num$2 + $num$2 is equal to $result"```

## if statement
- start with ```if``` followed by condition to evluate
-```then```
-# Code block to be executed
-ends with ``fi```
 
## conditions and if statements formed with comparative operators:
- eq = equals to
- ne = not equal to 
- lt = less than
- gt = greater than
- le = less/equal to
- ge = greater/ equal to

<br>

## Logical operators
- && = AND
- || = OR

## Compare strings:
- == equal  to
- != Not equal to 

## else and if
- ```elif``` allows us to add another condition (just like what we do do with if)


# Nested If Statements 

Nested `if` statements are a powerful feature in Bash scripting that allow you to check for multiple conditions sequentially or hierarchically. This control structure is crucial for handling complex decision-making processes where multiple layers of conditions must be evaluated.

## Basic Syntax

A nested `if` statement is essentially an `if` statement inside another `if` statement. Here's the basic structure:

```bash
if [ condition1 ]; then
    # Commands to execute if condition1 is true
    if [ condition2 ]; then
        # Commands to execute if both condition1 and condition2 are true
    else
        # Commands to execute if condition1 is true but condition2 is not
    fi
else
    # Commands to execute if condition1 is not true
fi
```

## While Loops in Bash Scripting

`while` loops are an essential control structure in Bash scripting, used to repeatedly execute a block of code as long as a specified condition remains true. They are particularly useful for tasks that need to continue until a certain condition changes, such as monitoring system statuses or processing user input.

## Basic Syntax

The basic syntax of a `while` loop in Bash is:

```bash
while [ condition ]
do
    # Commands to execute repeatedly
done

```
```bash 

while [ $index -lt ${#fruits[@]} ]
do 
    echo "Fruits: ${fruits[$index]}"
    ((index++))
done
```
- The expression 
```bash
    ${#fruits[@]}
```
is used to get the length of the array variable
- ```@``  refers to all contents in the array
- When ```#``` is used as in ```${array[@]}```, it helps determine the total number of elements in the array
- 




## for Loops

-Can be used with arrays, list of values or ranges to automate repetitive tasks

```bash
for variable in sequence
do 
    #command to be execued
done
```

e.g.

```bash
for (( i=1; i<=5; i++ ))
 do
    echo "Number $i"
done
```
1. Initialisation" ```i-1``` initialises variable to 1 before loop begins
2. Condition: ```i<=5``` Loop continues while i is less than or equal to 5
3. Increment: ```i++``` - i is incremented by 1 at the end off each loop iteration 


```bash

fruits=("apple" "banana" "orange")

for each_fruit in ${fruits[@]}
do
    echo "Fruits: ${each_fruit}"
done
```
1. ```fruits=("apple" "banana" "orange")``` - This is the array
2. ```for each_fruit in ${fruits[@]}``` - sets a loop variable ```each_fruit``` which takes takes on the value of each element in the ```fruits``` array one at a time. 

```bash
for number in $(seq 1 5)
do 
    echo "Number: $number"
done

```

1. Start for loop ```for number in```
2. variable ```number``` takes on each value generated by ```$(seq 1 5)``` in each iteration of the loop
3. ```$(seq 1 5)```: The ```seq``` command generates a sequence of numbers. Here it generates 1 - 5.


## break 

```bash

for (( i=1; i<=10; i ++ ))
do
    

    if [ $i -eq 5 ]
    then
        break
    fi
        echo "Number: $i"

done
```
- The for loop will break if i = 5 prematurely

## continue

```bash

for (( i=1; i<=10; i ++ ))
do
    

    if [ $i -eq 5 ]
    then
        continue
    fi
        echo "Number: $i"

done
```

- When i=5, the continue statement is encountered and the rest of the code for that iteration is skipped (5 is skipped)

## Basics of Functions

```bash 
function_name() {
    
    #code block to be executed
}
```

## Parameters

```bash 
$1 #1st parameter
$2 #2nd parameter
$# #Gives number of parameters
$@ #Prints the arguments
```

## User Inputs

- Use ```read``` command to capture users input

## Handling Bad Data
- **Bad data**: Errors caused to script by unwanted user inputs 

- Exit codes used to determine success or failiure 
- ```$?```
- ```return 1``` - failed
- ```return 0``` - works


## Piping
- Piping allows us to pass output of one command as the input of another command

### e.g.

```bash
get_file_count() {
    local directory="$1"
    local file_count=$(ls "$directory" | wc -l)

    echo "number of files in $directory: $file_count"
}

get_file_count "./"
```

- ```wc -l``` counts files in directory


<br>

# Error Handling

## Exit Codes

- ```$?``` - If a command executes successfully and you ```echo $?``` it should print 0
- Anyhing else means unsuccessful 

- ```set -e``` Stops script as son as command fails

- ```set -u``` forces script to stop when it encounters undefined variable

- ```set -x``` - prints each command before execution helping us understand what the script i doing at each step

- ```set -eux``` All above together

- ```set -o pipefail``` causes pipeline to not be executed when command before pipeline is not successfully executed

## Environment Variables

- can assign envirnment variables to local variables, making it easier to read and work with

```bash 

user=$USER
home=$HOME 
os_type=$OSTYPE 

echo "$user"

echo "$home"

echo "$os_type"

```

## Standard Environment Variables

-  